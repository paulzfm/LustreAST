\documentclass{article}
\usepackage[rounded]{syntax}
\usepackage{url}


\title{\bf Lustre Grammar}

\begin{document}
\maketitle

\section{Common}
\begin{grammar} \small

<char> ::= all printable character

<bool> ::= true | false

<integer> ::= [-+]?(0|[1-9][0-9]*)

<float> ::= [-+]?(0|[1-9][0-9]*)(.[0-9]*[1-9])?

<ident> ::= [a-zA-Z_][a-zA-Z0-9_]*

<clock> ::= (<ident> [, ident]*)

\end{grammar}

\section{Program}
\begin{grammar}

<program> ::= <nodeBlk>*

<nodeBlk> ::= <typeBlk> | <constBlk> | <funcBlk>

\end{grammar}

\section{Type}
\begin{grammar}

<typeBlk> ::= type <typeStmt>*

<typeStmt> ::= [<modifier>] <ident> = <type>;

<modifier> ::= private | public | protected

<type> ::= <atomType> |  <struct> | <type> \^{} <expr>la

<atomType> ::= char | bool | short | ushort | int | uint | float | real

<struct> ::= {<field> [, <field>]*}

<field> ::= <ident> : <type>

\end{grammar}

\section{Const}
\begin{grammar}

<constBlk> ::= const <constStmt>*

<constStmt> ::= <ident> : <type> = <expr>;


\end{grammar}

\section{Function}
\begin{grammar}

<funcBlk> ::= function <ident> <paramBlk> <returnBlk> <funcBody>

<paramBlk> ::= (<field> [, <field>]*)

<returnBlk> ::= returns(<field> [, <field>]*)

<funcBody> ::= [<varBlk>] let <eqStmt> tel

<varBlk> ::= var <field>*

<eqStmt> ::= <lhs> = <expr>

<lhs> := <ident> [, <ident>]*

\end{grammar}

\section{Expr}
\begin{grammar}

<expr> ::= <atomExpr> | <UnopExpr> | <BinopExpr> | <fieldExpr> | <structExpr> |
           <arrAccessExpr> | <arrInitExpr> | <preExpr> | <fbyExpr> | <arrowExpr> |
           <whenExpr> | <ifExpr> | <caseExpr> | <exprList> | <applyExpr> | (<expr>)

<atomExpr> ::= <bool> | <integer> | <float> | <char> | <ident>

<UnopExpr> ::= <unop> <expr>

<unop> ::= <atomType> | not | + | -

<BinopExpr> ::= <expr> <binop> <expr>

<binop> ::= + | - | * | / | div | mod | and | or | xor | = | != | \textless | \textgreater | \textless= | \textgreater=

<fieldExpr> ::= <expr>.<ident>

<structExpr> ::= {<expr> [, <expr>]*}

<arrAccessExpr> ::= <expr>[<expr>]

<arrInitExpr> ::= <expr> \^{} <expr>

<preExpr> ::= pre <expr>

<fbyExpr> ::= fby(<expr>; <integer>; <expr>)

<arrowExpr> ::= <expr> -\textgreater <expr>

<whenExpr> ::= <expr> when <ident>

<ifExpr> ::= if <expr> then <expr> else <expr>

<caseExpr> ::= case <expr> of ( | <pattern> : <expr>)*

<pattern> ::= <ident> | <integer> | <char> | <bool> | _

<exprList> ::= <expr> [, <expr>]*

<applyExpr> ::= <prefixExpr> | <highorderExpr>

<prefixExpr> ::= <prefixOp>(<exprList>)

<prefixOp> ::= <ident> | <prefixUnop> | <prefixBinOp>

<prefixUnOp> ::= short\(\$\) | int\(\$\) | float\(\$\) | real\(\$\) | not\(\$\) | +\(\$\) | -\(\$\)

<prefixBinOp> ::= \(\$\)+\(\$\) | \(\$\)-\(\$\) | \(\$\)*\(\$\) | \(\$\)/\(\$\) |
                  \(\$\)div\(\$\) | \(\$\)mod\(\$\) | \(\$\)and\(\$\) | \(\$\)or\(\$\) | \(\$\)xor\(\$\) |
                  \(\$\)=\(\$\) | \(\$\)<>\(\$\) | \(\$\)\(>\)\(\$\) | \(\$\)\(>\)=\(\$\) | \(\$\)\textless\(\$\) | \(\$\)\textless=\(\$\)

<highorderExpr> ::= (<highorderOp> <prefixOp>\textless \textless <integer> \textgreater \textgreater)(<exprList>)

<highorderOp> ::= fold | foldi | map | mapfold | mapi





\end{grammar}



\end{document}